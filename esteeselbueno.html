<!DOCTYPE html>
<html lang="es">

<head>
  ¬†
  <meta charset="utf-8" />
  ¬†
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  ¬† <title>Cajamarca Sostenible: Observatorio de Riesgos Urbanos (Leaflet/Cesium REAL)</title>
  ¬†
  ¬† ¬†
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  ¬†
  ¬† ¬† ¬†
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cesium@1.118.0/Build/Cesium/Widgets/widgets.css">

  ¬† <style>
    /* ----------------------------------------------------------- */
    /* ---------------------- üé® ESTILOS CSS üé® ---------------------- */
    /* ----------------------------------------------------------- */
    :root {
      --sidebar-width: 360px;
      --accent: #00695c;
      /* Verde esmeralda */
      --accent-dark: #004d40;
      --muted: #6b6b6b;
      --bg: #f7f9f8;
      --card-bg: #ffffff;
      --radius: 10px;
    }

    * {
      box-sizing: border-box
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: Inter, "Segoe UI", Arial, sans-serif;
      background: var(--bg);
      color: #222
    }

    a {
      color: inherit
    }

    /* ------------- Layout principal --------------- */
    #app {
      display: flex;
      height: 100vh;
      width: 100%;
      overflow: hidden;
    }

    /* Contenedor principal del mapa */
    #map-container {
      flex: 1;
      position: relative;
      height: 100vh;
      min-width: 0;
    }

    /* Contenedores de mapa */
    #leaflet-map,
    #cesium-globe {
      position: absolute;
      width: 100%;
      height: 100%;
      transition: opacity 0.5s ease;
    }

    /* Asegura que Cesium tenga el fondo negro por defecto */
    #cesium-globe {
      background: #000;
      display: none;
      /* Oculto por defecto */
    }

    /* Sidebar */
    #sidebar {
      width: var(--sidebar-width);
      background: var(--card-bg);
      padding: 20px;
      box-shadow: -10px 0 30px rgba(0, 0, 0, 0.1);
      overflow-y: auto;
      transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), box-shadow .3s;
      z-index: 900;
    }

    /* Plegado de sidebar en m√≥vil */
    #sidebar.collapsed {
      transform: translateX(100%);
      box-shadow: none;
    }

    /* Header dentro del sidebar */
    #sidebar header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }

    #sidebar h2 {
      margin: 0;
      font-size: 1.2rem;
      color: var(--accent-dark);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* Estilo para botones de control */
    #mapmode-btn,
    #menu-toggle,
    #close-sidebar {
      background: var(--card-bg);
      border: 1px solid #e6e6e6;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
      transition: all 0.2s ease;
      font-weight: 500;
    }

    #mapmode-btn:hover,
    #menu-toggle:hover,
    #close-sidebar:hover {
      background: var(--bg);
      border-color: var(--accent);
      color: var(--accent-dark);
    }

    #menu-toggle {
      display: none;
    }

    /* Controles flotantes (Bot√≥n 3D y Men√∫ m√≥vil) */
    #map-controls {
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 1000;
      display: flex;
      gap: 8px;
    }

    #map-controls.mobile-left {
      right: auto;
      left: 12px;
    }

    #mapmode-btn {
      margin-top: 0;
    }

    /* KPI cards - M√°s vibrantes */
    #kpi-cards {
      display: flex;
      gap: 12px;
      margin-top: 16px;
      margin-bottom: 10px;
    }

    .kpi-card {
      background: var(--card-bg);
      flex: 1;
      padding: 14px;
      border-radius: var(--radius);
      border-left: 5px solid var(--accent);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      transition: transform 0.3s ease;
    }

    .kpi-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.1);
    }

    .kpi-card h4 {
      margin: 0;
      font-weight: 600;
      font-size: 0.85rem;
      color: var(--accent)
    }

    .kpi-card p {
      margin: 6px 0 0 0;
      font-size: 1.5rem;
      font-weight: 800;
      color: #333;
      transition: color 0.3s ease;
    }

    /* CSS para el mensaje de modo 3D */
    .mode-3d-message {
      background: #fef0f0;
      color: #d32f2f;
      border-left: 4px solid #d32f2f;
      padding: 10px;
      margin-top: 15px;
      border-radius: 4px;
    }

    /* Estilos responsive */
    @media (max-width: 900px) {
      #sidebar {
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        transform: translateX(100%);
        width: 90%;
        max-width: 400px;
        padding: 15px;
      }

      #sidebar.open {
        transform: translateX(0);
      }

      #kpi-cards {
        flex-direction: column;
      }
    }
  </style>
</head>

<<body>

  <div id="app">
    <div id="map-container" aria-label="Map container">

      <div id="leaflet-map"></div>
      <div id="cesium-globe"></div>

      <div id="map-controls">
        <button id="mapmode-btn" title="Switch to 3D view">üåç Switch to 3D</button>
        <button id="menu-toggle">‚ò∞ Menu</button>
      </div>
    </div>

    <aside id="sidebar" aria-label="Sidebar panel">
      <header>
        <h2>üó∫Ô∏è Risk Observatory ‚Äî Cajamarca</h2>
        <div style="margin-left:auto; display:flex; gap: 8px;">
          <button id="close-sidebar" title="Close panel" style="display:none">‚úï</button>
        </div>
      </header>

      <!-- KPI CARDS -->
      <div id="kpi-cards">
        <div class="kpi-card">
          <h4>High-Risk Area</h4>
          <p id="kpi-alto">--</p>
        </div>
        <div class="kpi-card">
          <h4>Critical Vegetation (NDVI)</h4>
          <p id="kpi-ndvi">--</p>
          <div id="ndvi-bar" style="height: 5px; background: linear-gradient(to right, #f44336, #ffeb3b, #4caf50);
               border-radius: 2px; margin-top: 5px;">
          </div>
        </div>
      </div>

      <!-- 3D MODE ALERT -->
      <div id="mode-alert" class="mode-3d-message" style="display: none;">
        üö® <strong>3D MODE ACTIVE:</strong> Data interactions (clicks, layers)
        are handled in Cesium. The sidebar is in visualization mode.
      </div>

      <!-- AI MODULE -->
      <section class="chart-container">
        <div class="module-header">
          <h4>ü§ñ Risk Prediction (AI)</h4>
        </div>

        <div id="ai-module">
          <label>Mode:
            <select id="ai-mode">
              <option value="light">Light (weighted rule)</option>
              <option value="tfjs" disabled>Trainable (TensorFlow.js - LIBRARY REQUIRED)</option>
            </select>
          </label>

          <label class="range-label-wrap">NDVI:
            <input id="ai-ndvi" type="range" min="0" max="1" step="0.01" value="0.5">
            <span class="value-display">0.50</span>
          </label>

          <label class="range-label-wrap">LST (¬∞C):
            <input id="ai-lst" type="range" min="15" max="45" step="0.1" value="26">
            <span class="value-display">26.0</span>
          </label>

          <label class="range-label-wrap">Density (inhab/km¬≤):
            <input id="ai-den" type="range" min="0" max="10000" step="1" value="500">
            <span class="value-display">500</span>
          </label>

          <button id="ai-predict">üöÄ Run Prediction</button>
          <div id="ai-output" style="display:none;"></div>

          <div id="ai-train-area" style="display:none;margin-top:10px;">
            <p style="margin:0 0 8px 0">
              Local training (demo) ‚Äî generates a simple model with synthetic data.
            </p>
            <button id="ai-train">‚öôÔ∏è Train Model (demo)</button>
            <div id="ai-train-output" style="margin-top:8px"></div>
          </div>
        </div>
      </section>

      <!-- DATASETS -->
      <section class="chart-container">
        <h4>üìö Available Datasets (WRI)</h4>
        <div id="wri-info">Data ready for geospatial analysis.</div>
        <div id="wri-datasets">
          <ul id="dataset-list" style="padding-left:20px; margin-top:10px;">
            <li><strong>CO2_Emissions_2020</strong> (WRI demo) - Pollution</li>
            <li><strong>Forest_Cover_2019</strong> (WRI demo) - Resilience</li>
            <li><strong>Flood_Risk_Zones</strong> (WRI demo) - Vulnerability</li>
          </ul>
        </div>
      </section>

      <hr style="margin:16px 0;border:none;border-top:1px solid #eee">

      <!-- SELECTED AREA DETAILS -->
      <section id="area-info">
        <h3>Selected Area Details (Click on the Map)</h3>
        <p id="click-instruction" style="color:var(--muted)">
          Click on the map to view <strong>LST</strong>, <strong>NDVI</strong> and
          <strong>Density</strong> data for that specific area.
        </p>
        <div id="selected-metrics"></div>
      </section>

      <!-- CHART -->
      <section class="chart-container chart-wrap">
        <canvas id="riskChart"></canvas>
      </section>
    </aside>

  </div>


  ¬† ¬†
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  ¬†
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  ¬† ¬†
  <script src="https://cdn.jsdelivr.net/npm/cesium@1.118.0/Build/Cesium/Cesium.js"></script>
  ¬†
  ¬†
  <script>
    /* ----------------------------------------------------------- */
    /* -------------------- üíª L√ìGICA JAVASCRIPT üíª ------------------- */
    /* ----------------------------------------------------------- */

    // Variables de control
    const sidebar = document.getElementById('sidebar');
    const menuToggle = document.getElementById('menu-toggle');
    const mapControls = document.getElementById('map-controls');
    const closeSidebarBtn = document.getElementById('close-sidebar');
    const mapmodeBtn = document.getElementById('mapmode-btn');
    const leafletMapDiv = document.getElementById('leaflet-map');
    const cesiumGlobeDiv = document.getElementById('cesium-globe');
    const modeAlert = document.getElementById('mode-alert');
    const clickInstruction = document.getElementById('click-instruction');
    const ndviBar = document.getElementById('ndvi-bar');

    // Estado global
    let is3DMode = false;
    let mapInstance = null; // Leaflet instance
    let cesiumViewer = null; // Cesium Viewer instance
    let clickMarker = null;

    // Coordenadas de Cajamarca
    const CAJAMARCA_COORDS = [-7.1667, -78.5]; // Lat, Lng

    /* ----------------- UI: sidebar toggle (responsive) ----------------- */
    function updateResponsiveUI() {
      const w = window.innerWidth;
      if (w <= 900) {
        mapControls.classList.add('mobile-left');
        menuToggle.style.display = 'inline-flex';
        closeSidebarBtn.style.display = 'inline-block';
        sidebar.classList.add('collapsed');
      } else {
        mapControls.classList.remove('mobile-left');
        menuToggle.style.display = 'none';
        closeSidebarBtn.style.display = 'none';
        sidebar.classList.remove('collapsed');
        sidebar.classList.remove('open');
      }
    }
    window.addEventListener('resize', updateResponsiveUI);
    updateResponsiveUI();
    menuToggle && menuToggle.addEventListener('click', () => sidebar.classList.add('open'));
    closeSidebarBtn && closeSidebarBtn.addEventListener('click', () => sidebar.classList.remove('open'));


    /* ----------------- Map initialization: Leaflet ONLY (2D) ----------------- */
    function initLeafletMap() {
      if (mapInstance) mapInstance.remove();

      mapInstance = L.map(leafletMapDiv, { preferCanvas: true }).setView(CAJAMARCA_COORDS, 12);

      // Capa base gratuita de OpenStreetMap (OSM)
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      }).addTo(mapInstance);

      // Click handler para Leaflet
      mapInstance.on('click', function (e) {
        if (!is3DMode) handleMapClick({ lng: e.latlng.lng, lat: e.latlng.lat });
      });
    }

    // Llamada inicial
    initLeafletMap();

    /* ----------------- Map initialization: CesiumJS (3D) ----------------- */
    function initCesiumViewer() {
      // 1. Verificar si ya se inicializ√≥
      if (cesiumViewer) return;

      // 2. Configurar Cesium token
      // Cesium requiere un token para algunos servicios (como las im√°genes 3D por defecto), aunque el motor es gratuito.
      // Usamos el token de demostraci√≥n (funciona, pero se recomienda obtener uno propio en https://cesium.com/ion/tokens).
      Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyYTliOTViOC1jYmJmLTQzOWItODg0Ny1hNzg0YzJjYTljY2YiLCJpZCI6MTkzNTQ0LCJpYXQiOjE3MDcwNTEzNDl9.X1-wW1_g9R6yN1_X_e7D2Y3pQe2M5J6eW3d0P1v-f78';

      // 3. Inicializar el visor
      cesiumViewer = new Cesium.Viewer(cesiumGlobeDiv, {
        animation: false, // Desactivar widget de animaci√≥n
        baseLayerPicker: true, // Permitir cambio de capa base (incluye 3D)
        fullscreenButton: false, // Desactivar bot√≥n de pantalla completa
        geocoder: false, // Desactivar geocodificador
        homeButton: false, // Desactivar bot√≥n de inicio
        sceneModePicker: false, // Desactivar selector de modo de escena (2D, 3D)
        timeline: false, // Desactivar l√≠nea de tiempo
        navigationHelpButton: false, // Desactivar bot√≥n de ayuda
        infoBox: false, // Desactivar cuadro de informaci√≥n
        selectionIndicator: false // Desactivar indicador de selecci√≥n
      });

      // 4. Volar a Cajamarca con inclinaci√≥n para ver 3D
      cesiumViewer.camera.flyTo({
        destination: Cesium.Cartesian3.fromDegrees(CAJAMARCA_COORDS[1], CAJAMARCA_COORDS[0], 20000), // Lng, Lat, Altura (20km)
        orientation: {
          heading: Cesium.Math.toRadians(0.0), // Orientaci√≥n Norte
          pitch: Cesium.Math.toRadians(-35.0), // √Ångulo de inclinaci√≥n
          roll: 0.0
        },
        duration: 1.5 // Duraci√≥n del vuelo
      });

      console.log('CesiumJS Viewer inicializado.');
    }

    /* ----------------- Funci√≥n principal de toggle de modo de mapa ----------------- */
    mapmodeBtn.addEventListener('click', toggleMapMode);

    function toggleMapMode() {
      is3DMode = !is3DMode;

      if (is3DMode) {
        // Modo 3D (Cesium)
        initCesiumViewer();
        leafletMapDiv.style.display = 'none';
        cesiumGlobeDiv.style.display = 'block';
        mapmodeBtn.textContent = 'üìè Volver a 2D';
        mapmodeBtn.title = 'Cambiar a vista 2D (Leaflet)';
        modeAlert.style.display = 'block';
        clickInstruction.textContent = 'Interacciones de datos deshabilitadas en el modo 3D.';

      } else {
        // Modo 2D (Leaflet)
        leafletMapDiv.style.display = 'block';
        cesiumGlobeDiv.style.display = 'none';
        mapInstance.invalidateSize(); // Asegura que Leaflet se redimensione correctamente
        mapmodeBtn.textContent = 'üåç Cambiar a 3D';
        mapmodeBtn.title = 'Cambiar a vista 3D (CesiumJS)';
        modeAlert.style.display = 'none';
        clickInstruction.textContent = 'Haz clic en el mapa para ver los datos de LST, NDVI y Densidad de esa zona espec√≠fica.';
      }
    }

    /* -------------- Manejo de clicks en el mapa (simulaci√≥n de m√©tricas) -------------- */
    function handleMapClick(coords) {
      // Esta funci√≥n solo se ejecuta si NO estamos en 3D (ver listener en initLeafletMap)

      // 1. Simulaci√≥n de datos
      const ndvi = (Math.random() * 0.7 + 0.2).toFixed(2); // Rango 0.2 a 0.9
      const lst = (18 + Math.random() * 18).toFixed(1); // Rango 18 a 36
      const dens = Math.round(Math.random() * 6000);

      // 2. Animaci√≥n del marcador de click (Leaflet)
      if (clickMarker) mapInstance.removeLayer(clickMarker);
      clickMarker = L.circleMarker([coords.lat, coords.lng], {
        radius: 8,
        fillColor: 'var(--accent)',
        color: '#ffffff',
        weight: 2,
        opacity: 1,
        fillOpacity: 0.9
      }).addTo(mapInstance).bindPopup(`Datos: NDVI ${ndvi}, LST ${lst}¬∞C`).openPopup();
      mapInstance.flyTo([coords.lat, coords.lng], 12, { animate: true, duration: 1 });

      // 3. Actualizar panel lateral
      const html = `
¬† ¬† ¬† ¬† <p><strong>üìç Coordenadas:</strong> ${coords.lat.toFixed(4)}, ${coords.lng.toFixed(4)}</p>
¬† ¬† ¬† ¬† <p><strong>üåø NDVI (Salud):</strong> <span style="color:${parseFloat(ndvi) > 0.4 ? 'green' : 'orange'}; font-weight:700;">${ndvi}</span></p>
¬† ¬† ¬† ¬† <p><strong>üî• LST (¬∞C):</strong> <span style="color:${parseFloat(lst) > 30 ? 'red' : 'green'}; font-weight:700;">${lst}</span></p>
¬† ¬† ¬† ¬† <p><strong>üë• Densidad (hab/km¬≤):</strong> <span style="font-weight:700;">${dens.toLocaleString()}</span></p>
¬† ¬† ¬† `;
      document.getElementById('selected-metrics').innerHTML = html;

      // 4. Actualizar KPIs, animar riesgo e indicador visual NDVI
      const kpiAlto = document.getElementById('kpi-alto');
      const isHighRisk = (parseFloat(ndvi) < 0.3 || parseFloat(lst) > 32);
      kpiAlto.textContent = isHighRisk ? '¬°ALTO! ‚ö†Ô∏è' : 'Bajo/Medio ‚úÖ';
      kpiAlto.style.color = isHighRisk ? '#ff4500' : 'var(--accent-dark)';
      kpiAlto.classList.toggle('pulsing-kpi', isHighRisk);
      document.getElementById('kpi-ndvi').textContent = ndvi;

      const ndviPercent = parseFloat(ndvi) * 100;
      ndviBar.style.position = 'relative';
      ndviBar.style.cursor = 'pointer';
      ndviBar.innerHTML = `<div style="position: absolute; top: -7px; left: ${ndviPercent}%; transform: translateX(-50%); width: 14px; height: 14px; border-radius: 50%; background: white; border: 2px solid var(--accent-dark); box-shadow: 0 1px 3px rgba(0,0,0,0.3); transition: left 0.5s ease-out;"></div>`;


      // 5. Actualizar gr√°fico de riesgo
      updateRiskChart(parseFloat(ndvi), parseFloat(lst), dens);

      // 6. Cerrar sidebar si es m√≥vil (mejora UX)
      if (window.innerWidth <= 900) sidebar.classList.remove('open');
    }

    /* ----------------- Sincronizaci√≥n de Range Sliders con valores ----------------- */
    document.querySelectorAll('input[type="range"]').forEach(input => {
      const displaySpan = input.parentNode.querySelector('.value-display');
      if (displaySpan) {
        input.addEventListener('input', () => {
          displaySpan.textContent = parseFloat(input.value).toLocaleString(undefined, {
            minimumFractionDigits: input.step.split('.')[1]?.length || 0,
            maximumFractionDigits: input.step.split('.')[1]?.length || 0
          });
        });
      }
    });

    /* ----------------- IA simple (regla ponderada) ----------------- */
    document.getElementById('ai-predict').addEventListener('click', () => {
      const ndvi = parseFloat(document.getElementById('ai-ndvi').value);
      const lst = parseFloat(document.getElementById('ai-lst').value);
      const dens = parseFloat(document.getElementById('ai-den').value);
      const out = document.getElementById('ai-output');

      // Regla ponderada demo (0-1)
      const risk = Math.min(1, Math.max(0,
        0.5 * (1 - ndvi) + 0.35 * ((lst - 15) / 30) + 0.15 * (dens / 10000)
      ));
      const riskPct = Math.round(risk * 100);

      out.style.display = 'block';
      out.style.backgroundColor = `rgba(255, ${255 - riskPct * 2.55}, ${255 - riskPct * 2.55}, 0.8)`;
      out.innerHTML = `<div>Estimaci√≥n IA: <strong>Riesgo ${riskPct}%</strong> (${riskPct > 60 ? '¬°Alta prioridad!' : 'Prioridad baja/media'}).</div>`;
    });

    // Las funciones de Simulaci√≥n Clim√°tica y FIRMS/WRI se han eliminado para simplificar el c√≥digo en la respuesta final,
    // ya que el foco es la vista 3D, pero se pueden reintegrar.

    /* ----------------- Gr√°fico de riesgo (Chart.js) ----------------- */
    const ctx = document.getElementById('riskChart').getContext('2d');
    let riskChart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: ['NDVI', 'LST (¬∞C)', 'Densidad (/1000)'],
        datasets: [{
          label: 'Valor normalizado',
          data: [0.5 * 35, 26, 0.5 * 5], // Escala inicial
          backgroundColor: [
            'rgba(75, 192, 192, 0.7)',
            'rgba(255, 99, 132, 0.7)',
            'rgba(54, 162, 235, 0.7)'
          ],
          borderColor: 'rgba(255, 255, 255, 1)',
          borderWidth: 1,
          borderRadius: 8,
          hoverBackgroundColor: [
            'rgba(75, 192, 192, 0.9)',
            'rgba(255, 99, 132, 0.9)',
            'rgba(54, 162, 235, 0.9)'
          ]
        }]
      },
      options: {
        responsive: true,
        animation: { duration: 800, easing: 'easeOutQuart' },
        plugins: { legend: { display: false } },
        scales: {
          y: {
            beginAtZero: false,
            max: 35,
            ticks: { color: '#666' }
          },
          x: { ticks: { color: '#666' } }
        }
      }
    });

    function updateRiskChart(ndvi, lst, dens) {
      riskChart.data.datasets[0].data = [ndvi * 35, lst, dens / 1000 * 5];
      riskChart.update();
    }
  </script>
  <!-- ------------------ INICIO: Simulaciones y capas adicionales ------------------ -->
  <script>
    (function () {
      // --- Seguridad: asegurar que mapa Leaflet exista ---
      if (typeof mapInstance === 'undefined' || !mapInstance) {
        console.warn('Simulaci√≥n: mapInstance no detectado todav√≠a. Esta capa se a√±adir√° cuando el mapa est√© listo.');
        // Esperar a que window.mapInstance exista o que se dispare evento custom (reintentamos m√°s abajo)
      }

      /**************************************************************************
       * Utilidades peque√±as
       **************************************************************************/
      function safeGetMap() {
        if (typeof mapInstance !== 'undefined' && mapInstance) return mapInstance;
        return null;
      }

      function safeGetCesiumViewer() {
        if (typeof cesiumViewer !== 'undefined' && cesiumViewer) return cesiumViewer;
        return null;
      }

      function createElementFromHTML(htmlString) {
        const div = document.createElement('div');
        div.innerHTML = htmlString.trim();
        return div.firstChild;
      }

      // Color ramp utility para choropleth
      function getColorRamped(value, breaks, colors) {
        for (let i = 0; i < breaks.length; i++) {
          if (value <= breaks[i]) return colors[i];
        }
        return colors[colors.length - 1];
      }

      /**************************************************************************
       * Datos simulados (GeoJSON y arrays). Reempl√°zalos por tus datos reales.
       **************************************************************************/
      // Nota: coordenadas demo centradas en Cajamarca (~lat -7.17, lon -78.5).
      const simulatedAreas = {
        "type": "FeatureCollection",
        "features": [
          {
            "type": "Feature",
            "properties": {
              "id": "CAJ-01",
              "provincia": "Cajamarca (prov.)",
              "nombre": "Sector Centro - Cajamarca",
              "indice_acceso": 88.3,
              "deficiencia": "saneamiento",
              "cobertura_agua": 94,
              "cobertura_energia": 95,
              "cobertura_saneamiento": 78,
              "acceso_alimentacion": 92,
              "distancia_promedio_salud_min": 6,
              "tiempo_transporte_publico_min": 8,
              "densidad_poblacional_hab_km2": 11000,
              "temp": 15,
              "nota": "Sector urbano central con excelentes servicios de agua y energ√≠a; saneamiento mejora con inversiones recientes."
            },
            "geometry": {
              "type": "Polygon",
              "coordinates": [[
                [-78.52, -7.16],
                [-78.49, -7.16],
                [-78.49, -7.18],
                [-78.52, -7.18],
                [-78.52, -7.16]
              ]]
            }
          },

          {
            "type": "Feature",
            "properties": {
              "id": "BAJ-02",
              "provincia": "Bambamarca / Hualgayoc",
              "nombre": "Sector Hualgayoc",
              "indice_acceso": 61.4,
              "deficiencia": "cobertura_energia",
              "cobertura_agua": 75,
              "cobertura_energia": 58,
              "cobertura_saneamiento": 60,
              "acceso_alimentacion": 65,
              "distancia_promedio_salud_min": 22,
              "tiempo_transporte_publico_min": 30,
              "densidad_poblacional_hab_km2": 1800,
              "temp": 13,
              "nota": "Provincia con actividad minera cercana; centros poblados con cobertura parcial de servicios."
            },
            "geometry": {
              "type": "Polygon",
              "coordinates": [[
                [-78.84, -6.98],
                [-78.81, -6.98],
                [-78.81, -7.01],
                [-78.84, -7.01],
                [-78.84, -6.98]
              ]]
            }
          },

          {
            "type": "Feature",
            "properties": {
              "id": "CEL-03",
              "provincia": "Celend√≠n",
              "nombre": "Sector Celend√≠n",
              "indice_acceso": 64.9,
              "deficiencia": "saneamiento",
              "cobertura_agua": 70,
              "cobertura_energia": 72,
              "cobertura_saneamiento": 55,
              "acceso_alimentacion": 68,
              "distancia_promedio_salud_min": 18,
              "tiempo_transporte_publico_min": 20,
              "densidad_poblacional_hab_km2": 2500,
              "temp": 16,
              "nota": "√Årea semi-urbana con cobertura razonable de agua y energ√≠a; saneamiento es el componente m√°s d√©bil."
            },
            "geometry": {
              "type": "Polygon",
              "coordinates": [[
                [-78.44, -6.51],
                [-78.41, -6.51],
                [-78.41, -6.54],
                [-78.44, -6.54],
                [-78.44, -6.51]
              ]]
            }
          },

          {
            "type": "Feature",
            "properties": {
              "id": "CAJB-04",
              "provincia": "Cajabamba",
              "nombre": "Sector Cajabamba",
              "indice_acceso": 69.2,
              "deficiencia": "acceso_alimentacion",
              "cobertura_agua": 82,
              "cobertura_energia": 80,
              "cobertura_saneamiento": 65,
              "acceso_alimentacion": 56,
              "distancia_promedio_salud_min": 14,
              "tiempo_transporte_publico_min": 18,
              "densidad_poblacional_hab_km2": 2200,
              "temp": 14,
              "nota": "Cabecera provincial con servicios relativamente buenos; acceso a alimentos algo limitado por frecuencia de mercados."
            },
            "geometry": {
              "type": "Polygon",
              "coordinates": [[
                [-78.52, -7.41],
                [-78.49, -7.41],
                [-78.49, -7.44],
                [-78.52, -7.44],
                [-78.52, -7.41]
              ]]
            }
          },

          {
            "type": "Feature",
            "properties": {
              "id": "CHT-05",
              "provincia": "Chota",
              "nombre": "Sector Chota",
              "indice_acceso": 66.1,
              "deficiencia": "saneamiento",
              "cobertura_agua": 78,
              "cobertura_energia": 76,
              "cobertura_saneamiento": 52,
              "acceso_alimentacion": 70,
              "distancia_promedio_salud_min": 20,
              "tiempo_transporte_publico_min": 22,
              "densidad_poblacional_hab_km2": 2600,
              "temp": 18,
              "nota": "Ciudad intermedia con buena disponibilidad de agua y energ√≠a; saneamiento deficiente en barrios perif√©ricos."
            },
            "geometry": {
              "type": "Polygon",
              "coordinates": [[
                [-78.34, -6.52],
                [-78.31, -6.52],
                [-78.31, -6.55],
                [-78.34, -6.55],
                [-78.34, -6.52]
              ]]
            }
          },

          {
            "type": "Feature",
            "properties": {
              "id": "CTZ-06",
              "provincia": "Contumaz√°",
              "nombre": "Sector Contumaz√°",
              "indice_acceso": 57.3,
              "deficiencia": "cobertura_agua",
              "cobertura_agua": 45,
              "cobertura_energia": 68,
              "cobertura_saneamiento": 54,
              "acceso_alimentacion": 60,
              "distancia_promedio_salud_min": 30,
              "tiempo_transporte_publico_min": 40,
              "densidad_poblacional_hab_km2": 900,
              "temp": 20,
              "nota": "Zona rural-monta√±a con cobertura de agua limitada; transporte y salud presentan tiempos altos."
            },
            "geometry": {
              "type": "Polygon",
              "coordinates": [[
                [-78.08, -6.93],
                [-78.05, -6.93],
                [-78.05, -6.96],
                [-78.08, -6.96],
                [-78.08, -6.93]
              ]]
            }
          },

          {
            "type": "Feature",
            "properties": {
              "id": "CTV-07",
              "provincia": "Cutervo",
              "nombre": "Sector Cutervo",
              "indice_acceso": 60.7,
              "deficiencia": "saneamiento",
              "cobertura_agua": 62,
              "cobertura_energia": 70,
              "cobertura_saneamiento": 48,
              "acceso_alimentacion": 72,
              "distancia_promedio_salud_min": 24,
              "tiempo_transporte_publico_min": 26,
              "densidad_poblacional_hab_km2": 1600,
              "temp": 22,
              "nota": "√Årea con infraestructura b√°sica parcial; saneamiento urbano y periurbano con brechas notables."
            },
            "geometry": {
              "type": "Polygon",
              "coordinates": [[
                [-77.89, -6.60],
                [-77.86, -6.60],
                [-77.86, -6.63],
                [-77.89, -6.63],
                [-77.89, -6.60]
              ]]
            }
          },

          {
            "type": "Feature",
            "properties": {
              "id": "JAE-08",
              "provincia": "Ja√©n",
              "nombre": "Sector Ja√©n",
              "indice_acceso": 72.5,
              "deficiencia": "cobertura_saneamiento",
              "cobertura_agua": 82,
              "cobertura_energia": 85,
              "cobertura_saneamiento": 60,
              "acceso_alimentacion": 85,
              "distancia_promedio_salud_min": 12,
              "tiempo_transporte_publico_min": 15,
              "densidad_poblacional_hab_km2": 3200,
              "temp": 24,
              "nota": "Ciudad con climas m√°s c√°lidos; buenas coberturas de agua y energ√≠a, saneamiento en mejora."
            },
            "geometry": {
              "type": "Polygon",
              "coordinates": [[
                [-78.14, -5.70],
                [-78.11, -5.70],
                [-78.11, -5.73],
                [-78.14, -5.73],
                [-78.14, -5.70]
              ]]
            }
          },

          {
            "type": "Feature",
            "properties": {
              "id": "SIG-09",
              "provincia": "San Ignacio",
              "nombre": "Sector San Ignacio",
              "indice_acceso": 58.9,
              "deficiencia": "cobertura_agua",
              "cobertura_agua": 50,
              "cobertura_energia": 65,
              "cobertura_saneamiento": 55,
              "acceso_alimentacion": 70,
              "distancia_promedio_salud_min": 28,
              "tiempo_transporte_publico_min": 35,
              "densidad_poblacional_hab_km2": 1400,
              "temp": 26,
              "nota": "Provincia fronteriza con Amazon√≠a; servicios b√°sicos heterog√©neos, agua tiene brechas importantes."
            },
            "geometry": {
              "type": "Polygon",
              "coordinates": [[
                [-78.48, -5.12],
                [-78.45, -5.12],
                [-78.45, -5.15],
                [-78.48, -5.15],
                [-78.48, -5.12]
              ]]
            }
          },

          {
            "type": "Feature",
            "properties": {
              "id": "SMR-10",
              "provincia": "San Marcos",
              "nombre": "Sector San Marcos",
              "indice_acceso": 63.8,
              "deficiencia": "cobertura_agua",
              "cobertura_agua": 58,
              "cobertura_energia": 72,
              "cobertura_saneamiento": 60,
              "acceso_alimentacion": 70,
              "distancia_promedio_salud_min": 20,
              "tiempo_transporte_publico_min": 22,
              "densidad_poblacional_hab_km2": 1300,
              "temp": 17,
              "nota": "Zona de transici√≥n andina con cobertura variable; agua y transporte mejorables."
            },
            "geometry": {
              "type": "Polygon",
              "coordinates": [[
                [-78.68, -6.27],
                [-78.65, -6.27],
                [-78.65, -6.30],
                [-78.68, -6.30],
                [-78.68, -6.27]
              ]]
            }
          },

          {
            "type": "Feature",
            "properties": {
              "id": "SMG-11",
              "provincia": "San Miguel",
              "nombre": "Sector San Miguel",
              "indice_acceso": 55.6,
              "deficiencia": "cobertura_agua",
              "cobertura_agua": 42,
              "cobertura_energia": 60,
              "cobertura_saneamiento": 50,
              "acceso_alimentacion": 62,
              "distancia_promedio_salud_min": 32,
              "tiempo_transporte_publico_min": 45,
              "densidad_poblacional_hab_km2": 700,
              "temp": 16,
              "nota": "Provincia con alta dispersi√≥n poblacional; brechas fuertes en agua y transporte."
            },
            "geometry": {
              "type": "Polygon",
              "coordinates": [[
                [-77.98, -6.28],
                [-77.95, -6.28],
                [-77.95, -6.31],
                [-77.98, -6.31],
                [-77.98, -6.28]
              ]]
            }
          },

          {
            "type": "Feature",
            "properties": {
              "id": "SPB-12",
              "provincia": "San Pablo",
              "nombre": "Sector San Pablo",
              "indice_acceso": 59.0,
              "deficiencia": "saneamiento",
              "cobertura_agua": 66,
              "cobertura_energia": 64,
              "cobertura_saneamiento": 45,
              "acceso_alimentacion": 60,
              "distancia_promedio_salud_min": 26,
              "tiempo_transporte_publico_min": 30,
              "densidad_poblacional_hab_km2": 1100,
              "temp": 18,
              "nota": "√Årea con condiciones rurales-urbanas mixtas; saneamiento reporta las mayores brechas."
            },
            "geometry": {
              "type": "Polygon",
              "coordinates": [[
                [-78.35, -6.98],
                [-78.32, -6.98],
                [-78.32, -7.01],
                [-78.35, -7.01],
                [-78.35, -6.98]
              ]]
            }
          },

          {
            "type": "Feature",
            "properties": {
              "id": "SCR-13",
              "provincia": "Santa Cruz",
              "nombre": "Sector Santa Cruz",
              "indice_acceso": 54.2,
              "deficiencia": "cobertura_agua",
              "cobertura_agua": 38,
              "cobertura_energia": 60,
              "cobertura_saneamiento": 42,
              "acceso_alimentacion": 58,
              "distancia_promedio_salud_min": 35,
              "tiempo_transporte_publico_min": 48,
              "densidad_poblacional_hab_km2": 600,
              "temp": 19,
              "nota": "Provincia con dispersion poblacional y acceso irregular a redes; agua y transporte son los retos principales."
            },
            "geometry": {
              "type": "Polygon",
              "coordinates": [[
                [-78.60, -7.82],
                [-78.57, -7.82],
                [-78.57, -7.85],
                [-78.60, -7.85],
                [-78.60, -7.82]
              ]]
            }
          }
        ]
      };

      // Puntos de contaminaci√≥n simulada (aire / agua)
      const puntosContaminacionSim = [
        { nombre: "Zona Industrial Norte", tipo: "Aire", valor: 140, coords: [-78.521, -7.152] },
        { nombre: "Vertido R√≠o San Pedro", tipo: "Agua", valor: 85, coords: [-78.519, -7.154] },
        { nombre: "Quema Residual - Sector B", tipo: "Aire", valor: 110, coords: [-78.505, -7.145] }
      ];

      // Propuestas de centros de salud
      const propuestasSalud = [
        { nombre: "Centro Propuesto - Bambamarca Rural", lat: -6.6850, lon: -78.5401, cobertura: 9800 },
        { nombre: "Centro Propuesto - Cutervo Alto", lat: -6.3785, lon: -78.8230, cobertura: 11500 },
        { nombre: "Centro Propuesto - Chota Este", lat: -6.5582, lon: -78.6389, cobertura: 10200 },
        { nombre: "Centro Propuesto - Celend√≠n Norte", lat: -6.8487, lon: -78.1451, cobertura: 8800 },
        { nombre: "Centro Propuesto - San Marcos Andino", lat: -7.3458, lon: -78.1505, cobertura: 9600 },
        { nombre: "Centro Propuesto - Contumaz√° Alto", lat: -7.3609, lon: -78.9652, cobertura: 7900 },
        { nombre: "Centro Propuesto - Santa Cruz Rural", lat: -6.7681, lon: -78.9744, cobertura: 7200 },
        { nombre: "Centro Propuesto - San Miguel Oeste", lat: -6.9926, lon: -78.8471, cobertura: 9400 },
        { nombre: "Centro Propuesto - San Pablo Central", lat: -7.1215, lon: -78.8258, cobertura: 8100 },
        { nombre: "Centro Propuesto - Cajabamba Rural Sur", lat: -7.6669, lon: -78.0547, cobertura: 8900 },
        { nombre: "Centro Propuesto - Cajamarca Este (Periurbano)", lat: -7.1584, lon: -78.4863, cobertura: 11500 },
        { nombre: "Centro Propuesto - Namora Alto", lat: -7.2031, lon: -78.3365, cobertura: 8600 },
        { nombre: "Centro Propuesto - Ba√±os del Inca Rural", lat: -7.1427, lon: -78.5562, cobertura: 10400 },
        { nombre: "Centro Propuesto - Jes√∫s Andino", lat: -7.0624, lon: -78.6390, cobertura: 7500 },
        { nombre: "Centro Propuesto - Cosp√°n Rural", lat: -7.0232, lon: -78.4416, cobertura: 6600 },
        { nombre: "Centro Propuesto - Lajas (Chota)", lat: -6.5284, lon: -78.6305, cobertura: 7800 },
        { nombre: "Centro Propuesto - Huambos (Chota Sur)", lat: -6.6301, lon: -78.8220, cobertura: 8300 },
        { nombre: "Centro Propuesto - San Luis de Lucma", lat: -6.9302, lon: -78.6235, cobertura: 7000 }
      ];


      // Parques simulados (pol√≠gonos)
      const dataParquesSim = {
        "type": "FeatureCollection",
        "features": [
          // Plaza principal / Plaza de Armas (verificada)
          {
            "type": "Feature",
            "properties": { "nombre": "Plaza de Armas", "area_verde_m2_hab": 15, "deficit": false, "source": "OSM/123coordenadas" },
            "geometry": { "type": "Point", "coordinates": [-78.5174766, -7.1570468] }
          },

          // Parques centrales y plazas verificadas
          { "type": "Feature", "properties": { "nombre": "Parque Las Flores", "source": "Mapcarta/OSM" }, "geometry": { "type": "Point", "coordinates": [-78.519718, -7.153394] } },
          { "type": "Feature", "properties": { "nombre": "Parque Ecol√≥gico", "source": "Mapcarta/OSM" }, "geometry": { "type": "Point", "coordinates": [-78.52064, -7.14769] } },
          { "type": "Feature", "properties": { "nombre": "Parque El Amauta", "source": "Waze/local listings" }, "geometry": { "type": "Point", "coordinates": [-78.5232273, -7.143912] } },
          { "type": "Feature", "properties": { "nombre": "Parque Santa Apolonia", "source": "Mapcarta/OSM" }, "geometry": { "type": "Point", "coordinates": [-78.51849, -7.15981] } },
          { "type": "Feature", "properties": { "nombre": "Plazuela San Jos√©", "source": "Mapcarta/OSM" }, "geometry": { "type": "Point", "coordinates": [-78.52056, -7.15278] } },
          { "type": "Feature", "properties": { "nombre": "Parque Ayacucho (Infantil)", "source": "Gob.pe / noticias locales (geocodificado)" }, "geometry": { "type": "Point", "coordinates": [-78.5120, -7.1608] } },

          // Otros parques muy citados / verificables en directorios y mapas
          { "type": "Feature", "properties": { "nombre": "Parque La Colmena", "source": "OSM/municipal-list" }, "geometry": { "type": "Point", "coordinates": [-78.50806, -7.157222] } },
          { "type": "Feature", "properties": { "nombre": "Parque La Merced", "source": "municipal-list/estimado" }, "geometry": { "type": "Point", "coordinates": [-78.5158, -7.1492] } },
          { "type": "Feature", "properties": { "nombre": "Parque La Cultura", "source": "municipal-list/estimado" }, "geometry": { "type": "Point", "coordinates": [-78.5112, -7.1701] } },
          { "type": "Feature", "properties": { "nombre": "Parque El Estadio", "source": "municipal-list/estimado" }, "geometry": { "type": "Point", "coordinates": [-78.5075, -7.1635] } },
          { "type": "Feature", "properties": { "nombre": "Alameda de los Incas", "source": "local tourism / municipal" }, "geometry": { "type": "Point", "coordinates": [-78.5110, -7.1590] } },
          { "type": "Feature", "properties": { "nombre": "Parque La Esperanza", "source": "municipal-list/estimado" }, "geometry": { "type": "Point", "coordinates": [-78.4945, -7.1700] } },

          // Parques y plazuelas documentados en OSM/Mapcarta / directorios locales
          { "type": "Feature", "properties": { "nombre": "Parque San Francisco", "source": "OSM/Mapcarta" }, "geometry": { "type": "Point", "coordinates": [-78.5165, -7.1625] } },
          { "type": "Feature", "properties": { "nombre": "Parque San Mart√≠n", "source": "municipal-list/estimado" }, "geometry": { "type": "Point", "coordinates": [-78.5210, -7.1615] } },
          { "type": "Feature", "properties": { "nombre": "Plazuela La Merced", "source": "municipal-list/estimado" }, "geometry": { "type": "Point", "coordinates": [-78.5133, -7.1478] } },
          { "type": "Feature", "properties": { "nombre": "Parque Las Palmeras", "source": "local listings/OSM" }, "geometry": { "type": "Point", "coordinates": [-78.5295, -7.1488] } },
          { "type": "Feature", "properties": { "nombre": "Parque Mirador / Cerro Santa Apolonia (mirador)", "source": "OSM / Wikiloc" }, "geometry": { "type": "Point", "coordinates": [-78.5180, -7.1598] } },

          // Parques de barrios y plazuelas (geocodificados desde direcciones y mapas)
          { "type": "Feature", "properties": { "nombre": "Parque Los Pinos", "source": "geocodificado" }, "geometry": { "type": "Point", "coordinates": [-78.5280, -7.1588] } },
          { "type": "Feature", "properties": { "nombre": "Parque San Pedro", "source": "geocodificado" }, "geometry": { "type": "Point", "coordinates": [-78.5218, -7.1687] } },
          { "type": "Feature", "properties": { "nombre": "Parque Huamachuco / Plazuela Huamachuco", "source": "municipal-list/estimado" }, "geometry": { "type": "Point", "coordinates": [-78.5255, -7.1462] } },
          { "type": "Feature", "properties": { "nombre": "Parque El Bosque", "source": "local listings/OSM" }, "geometry": { "type": "Point", "coordinates": [-78.4878, -7.1586] } },
          { "type": "Feature", "properties": { "nombre": "Parque La Merced Grande", "source": "municipal-list/estimado" }, "geometry": { "type": "Point", "coordinates": [-78.5192, -7.1468] } },

          // M√°s parques citados en directorios municipales y turismo local (geocodificados)
          { "type": "Feature", "properties": { "nombre": "Parque La Alameda", "source": "municipal-list/estimado" }, "geometry": { "type": "Point", "coordinates": [-78.5123, -7.1742] } },
          { "type": "Feature", "properties": { "nombre": "Plazuela San Roque", "source": "municipal-list/estimado" }, "geometry": { "type": "Point", "coordinates": [-78.5072, -7.1683] } },
          { "type": "Feature", "properties": { "nombre": "Parque San Sebasti√°n", "source": "municipal-list/estimado" }, "geometry": { "type": "Point", "coordinates": [-78.5060, -7.1483] } },
          { "type": "Feature", "properties": { "nombre": "Parque San Miguelito", "source": "geocodificado" }, "geometry": { "type": "Point", "coordinates": [-78.4987, -7.1690] } },
          { "type": "Feature", "properties": { "nombre": "Parque Los Jazmines", "source": "geocodificado" }, "geometry": { "type": "Point", "coordinates": [-78.5265, -7.1512] } },
          { "type": "Feature", "properties": { "nombre": "Plazuela Ayacucho", "source": "gob.pe (nota local) / geocodificado" }, "geometry": { "type": "Point", "coordinates": [-78.5120, -7.1600] } }
        ]
      };


      // Vertederos simulados
      const vertederosSim = [
        { nombre: "Vertedero Cajamarca - Palturo", lat: -7.1900, lon: -78.4400, estado: "Activo" },
        { nombre: "Vertedero Jes√∫s Alto", lat: -7.2105, lon: -78.5302, estado: "Activo" },
        { nombre: "Vertedero Namora Sur", lat: -7.2350, lon: -78.3750, estado: "Propuesto" },
        { nombre: "Vertedero Cosp√°n Rural", lat: -7.0604, lon: -78.4289, estado: "Propuesto" },
        { nombre: "Vertedero Cutervo Alto", lat: -6.3205, lon: -78.8602, estado: "Activo" },
        { nombre: "Vertedero Chota Pampa", lat: -6.5503, lon: -78.6104, estado: "Activo" },
        { nombre: "Vertedero San Pablo Norte", lat: -7.0508, lon: -78.7901, estado: "En proceso de clausura" },
        { nombre: "Vertedero San Marcos Andino", lat: -7.3401, lon: -78.2004, estado: "Activo" },
        { nombre: "Vertedero Contumaz√° Centro", lat: -7.3807, lon: -78.9405, estado: "Propuesto" },
        { nombre: "Vertedero Celend√≠n Alto", lat: -6.8302, lon: -78.1604, estado: "Activo" },
        { nombre: "Vertedero Santa Cruz Rural", lat: -6.7600, lon: -78.9802, estado: "Propuesto" },
        { nombre: "Vertedero San Miguel Oeste", lat: -6.9805, lon: -78.8303, estado: "Activo" },
        { nombre: "Vertedero Cajabamba Sur", lat: -7.6802, lon: -78.0703, estado: "En proceso de clausura" },
        { nombre: "Vertedero Huambos Alto", lat: -6.6502, lon: -78.8205, estado: "Activo" },
        { nombre: "Vertedero Lajas (Chota)", lat: -6.5301, lon: -78.6306, estado: "Clausurado" },
        { nombre: "Vertedero San Luis de Lucma", lat: -6.9205, lon: -78.6203, estado: "Propuesto" },
        { nombre: "Vertedero Namora Norte", lat: -7.1800, lon: -78.3500, estado: "Activo" },
        { nombre: "Vertedero Sector Alto Pucar√°", lat: -7.3001, lon: -78.4807, estado: "Clausurado" }
      ];


      // Cobertura de energia por √°rea (usamos mismos pol√≠gonos de simulatedAreas pero podr√≠amos tener GeoJSON separado)
      // --- FIN datos simulados ---

      /**************************************************************************
       * Funci√≥n: √≠ndice compuesto de prioridad (puedes ajustar pesos)
       **************************************************************************/
      function calcularPrioridad(areaProps) {
        // pesos (ajustables)
        const wAcceso = 0.30;          // importa el acceso a servicios
        const wContaminacion = 0.25;   // exposici√≥n a contaminantes
        const wEnergia = 0.20;         // falta de energ√≠a
        const wCalor = 0.25;           // riesgo t√©rmico
        // normalizaciones:
        // - indice_acceso: 0 (peor) - 100 (mejor) -> invertimos
        const accesoScore = 100 - (Number(areaProps.indice_acceso) || 50); // si falta, 50 por defecto
        // - contaminacion: suponemos rango 0-200 (ajusta seg√∫n tus datos)
        const contScore = Math.min(200, Number(areaProps.contaminacion || 50)) / 200 * 100;
        // - cobertura_energia: 0 (peor) - 100 (mejor) -> invertimos
        const energiaScore = 100 - (Number(areaProps.cobertura_energia) || 60);
        // - temp: normalizamos sobre 40¬∞C m√°xima esperada (ajusta)
        const calorScore = Math.min(40, Number(areaProps.temp || 28)) / 40 * 100;

        const raw = (accesoScore * wAcceso) + (contScore * wContaminacion) + (energiaScore * wEnergia) + (calorScore * wCalor);
        // escala 0-100
        return Math.round(Math.min(100, Math.max(0, raw)));
      }

      /**************************************************************************
       * Leaflet: creaci√≥n de capas simuladas
       **************************************************************************/
      let accesoLayer = null;
      let contaminacionLayer = null;
      let saludProposalsLayer = null;
      let parquesLayer = null;
      let crecimientoTileLayer = null;
      let calorLayer = null;
      let vertederosLayer = null;
      let energiaLayer = null;

      function buildAccessLayer(geojson) {
        // Choropleth - √≠ndice de acceso (0 - 100)
        return L.geoJSON(geojson, {
          style: feature => {
            const v = Number(feature.properties.indice_acceso);
            const color = getColorRamped(v, [20, 40, 60, 80], ['#fc8d59', '#fee08b', '#d9ef8b', '#91cf60', '#1a9850']);
            return { color: '#ffffff', weight: 1, fillColor: color, fillOpacity: 0.75 };
          },
          onEachFeature: (feature, layer) => {
            layer.bindPopup(`
          <b>${feature.properties.nombre}</b><br>
          √çndice de acceso: <strong>${feature.properties.indice_acceso}</strong><br>
          Deficiencia principal: <strong>${feature.properties.deficiencia}</strong><br>
          Contaminaci√≥n (sim): ${feature.properties.contaminacion}<br>
          Cobertura energ√≠a: ${feature.properties.cobertura_energia}%
        `);
            layer.on('mouseover', () => layer.setStyle({ weight: 2 }));
            layer.on('mouseout', () => layer.setStyle({ weight: 1 }));
          }
        });
      }

      function buildContaminacionPoints(points) {
        const lg = L.layerGroup();
        points.forEach(p => {
          const color = p.tipo === 'Aire' ? '#d7191c' : '#2b83ba';
          const r = Math.min(18, Math.max(6, p.valor / 10));
          const marker = L.circleMarker([p.coords[1], p.coords[0]], {
            radius: r,
            fillColor: color,
            color: '#ffffff',
            weight: 1,
            fillOpacity: 0.85
          }).bindPopup(`<b>${p.nombre}</b><br>Tipo: ${p.tipo}<br>Valor: ${p.valor}<br>Estado: ${p.valor > 100 ? '<strong>Cr√≠tico</strong>' : 'Moderado'}`);
          lg.addLayer(marker);
        });
        return lg;
      }

      function buildSaludProposalMarkers(proposals) {
        const lg = L.layerGroup();
        proposals.forEach(p => {
          const marker = L.marker([p.lat, p.lon], {
            title: p.nombre,
            icon: L.icon({
              iconUrl: 'img/markgreen.png',
              iconSize: [28, 28],
              iconAnchor: [14, 28]
            })
          }).bindPopup(`<b>${p.nombre}</b><br>Cobertura estimada: ${p.cobertura.toLocaleString()} hab`);
          lg.addLayer(marker);
        });
        return lg;
      }

      function buildParquesLayer(geojson) {
        return L.geoJSON(geojson, {
          style: f => ({
            fillColor: f.properties.deficit ? '#f03b20' : '#31a354',
            color: '#ffffff',
            weight: 0.6,
            fillOpacity: 0.65
          }),
          onEachFeature: (f, l) => {
            l.bindPopup(`<b>${f.properties.nombre}</b><br>√Årea verde (m¬≤/hab): ${f.properties.area_verde_m2_hab}<br>D√©ficit: ${f.properties.deficit ? 'S√≠' : 'No'}`);
          }
        });
      }

      function buildVertederosMarkers(list) {
        const lg = L.layerGroup();
        list.forEach(v => {
          const m = L.marker([v.lat, v.lon], {
            icon: L.icon({
              iconUrl: 'img/mark.png',
              iconSize: [26, 26],
              iconAnchor: [13, 26]
            })
          }).bindPopup(`<b>${v.nombre}</b><br>Estado: ${v.estado}`);
          lg.addLayer(m);
        });
        return lg;
      }

      function buildEnergiaLayer(areasGeojson) {
        // reutilizamos simulatedAreas para ejemplo
        return L.geoJSON(areasGeojson, {
          style: f => {
            const cov = Number(f.properties.cobertura_energia || 60);
            const color = getColorRamped(cov, [40, 60, 80], ['#d7191c', '#fdae61', '#a6d96a', '#1a9850']);
            return { color: '#fff', weight: 1, fillColor: color, fillOpacity: 0.7 };
          },
          onEachFeature: (f, l) => {
            l.bindPopup(`<b>${f.properties.nombre}</b><br>Cobertura el√©ctrica: ${f.properties.cobertura_energia}%`);
          }
        });
      }

      function buildCalorLayer(areasGeojson) {
        return L.geoJSON(areasGeojson, {
          style: f => {
            const t = Number(f.properties.temp || 28);
            const c = getColorRamped(t, [26, 28, 30, 32], ['#a6d96a', '#fdae61', '#f46d43', '#d73027', '#7f0000']);
            return { color: '#fff', weight: 1, fillColor: c, fillOpacity: 0.7 };
          },
          onEachFeature: (f, l) => {
            const prioridad = calcularPrioridad(f.properties);
            l.bindPopup(`<b>${f.properties.nombre}</b><br>Temp: ${f.properties.temp}¬∞C<br>Prioridad calculada: ${prioridad}`);
          }
        });
      }

      /**************************************************************************
       * Funciones de inicializaci√≥n de capas (se ejecutan cuando mapInstance existe)
       **************************************************************************/
      function initSimulatedLayers() {
        const map = safeGetMap();
        if (!map) {
          console.warn('initSimulatedLayers: Leaflet map no disponible todav√≠a. Reintentando en 500ms...');
          setTimeout(initSimulatedLayers, 500);
          return;
        }

        // Construir capas
        accesoLayer = buildAccessLayer(simulatedAreas);
        contaminacionLayer = buildContaminacionPoints(puntosContaminacionSim);
        saludProposalsLayer = buildSaludProposalMarkers(propuestasSalud);
        parquesLayer = buildParquesLayer(dataParquesSim);
        vertederosLayer = buildVertederosMarkers(vertederosSim);
        energiaLayer = buildEnergiaLayer(simulatedAreas);
        calorLayer = buildCalorLayer(simulatedAreas);

        // Simulaci√≥n de "crecimiento urbano" como tiles placeholder (usa URL de tiles si la tienes)
        crecimientoTileLayer = L.tileLayer('', {
          attribution: 'Crecimiento urbano (simulado)'
        });

        // A√±adir por defecto algunas capas
        accesoLayer.addTo(map);
        contaminacionLayer.addTo(map);
        parquesLayer.addTo(map);

        // Panel de control de capas
        const overlays = {
          "Access to Services (Index)": accesoLayer,
          "Pollution (points)": contaminacionLayer,
          "Proposals - Health Centers": saludProposalsLayer,
          "Parks (deficit vs sufficient)": parquesLayer,
          "Urban Growth (simulated tiles)": crecimientoTileLayer,
          "Thermal Risk Zones": calorLayer,
          "Proposals - Landfills": vertederosLayer,
          "Electric Coverage (%)": energiaLayer
        };


        L.control.layers(null, overlays, { collapsed: false, position: 'topleft' }).addTo(map);

        // A√±adir bot√≥n personalizado en mapa para "Calcular Prioridad para todas las √°reas"
        const PriorityControl = L.Control.extend({
          options: { position: 'topright' },
          onAdd: function () {
            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
            container.style.background = '#fff';
            container.style.padding = '4px';
            container.style.cursor = 'pointer';
            container.title = 'Calcular √≠ndice de prioridad para √°reas simuladas';
            container.innerHTML = 'üîé Priorizar';
            L.DomEvent.disableClickPropagation(container);
            container.onclick = function () {
              calcularYMostrarPrioridadesLeaflet();
            };
            return container;
          }
        });
        map.addControl(new PriorityControl());
      }

      /**************************************************************************
       * Ejecutar c√°lculo de prioridades y pintar resultados (Leaflet + Chart + HTML)
       **************************************************************************/
      function calcularYMostrarPrioridadesLeaflet() {
        const map = safeGetMap();
        if (!map) return;

        // Calcular prioridad para cada pol√≠gono en simulatedAreas
        const features = simulatedAreas.features;
        const results = features.map(f => {
          const p = calcularPrioridad(f.properties);
          // Guardamos en properties para persistencia
          f.properties.prioridad = p;
          return { id: f.properties.id, nombre: f.properties.nombre, prioridad: p };
        });

        // Ordenar de mayor a menor
        results.sort((a, b) => b.prioridad - a.prioridad);

        // Mostrar en el panel IA (existente)
        const out = document.getElementById('ai-output');
        if (out) {
          out.style.display = 'block';
          out.style.padding = '8px';
          out.innerHTML = `<h4>√çndice de Prioridad (simulado)</h4>
        <ol>
          ${results.map(r => `<li><strong>${r.nombre}</strong>: ${r.prioridad}%</li>`).join('')}
        </ol>
        <small>Este √≠ndice es una simulaci√≥n basada en variables sint√©ticas. Reemplazar datos por mediciones reales para decisiones operativas.</small>
      `;
        }

        // Actualizar estilo de la capa de acceso para reflejar prioridad (borde + popup)
        if (accesoLayer) {
          accesoLayer.eachLayer(layer => {
            const props = layer.feature && layer.feature.properties;
            if (props && typeof props.prioridad !== 'undefined') {
              const edgeColor = props.prioridad > 65 ? '#7f0000' : props.prioridad > 45 ? '#d73027' : '#2b8cbe';
              layer.setStyle({ color: edgeColor, weight: 2 });
              layer.bindPopup(layer.getPopup().getContent() + `<br><b>Prioridad intervenci√≥n:</b> ${props.prioridad}%`);
            }
          });
        }

        // Crear/actualizar entidades 3D en Cesium si est√° activo
        const viewer = safeGetCesiumViewer();
        if (viewer) {
          // remover entidades previas que a√±adimos con tag 'simulated-priority'
          const prev = viewer.entities.values.filter(e => e.name && e.name.startsWith('PRIORITY_'));
          prev.forEach(e => viewer.entities.remove(e));

          // A√±adir nuevas extrusiones
          simulatedAreas.features.forEach((f, idx) => {
            const coords = f.geometry.coordinates[0]; // [ [lon,lat], ... ]
            // convertimos a array de long, lat, long, lat...
            const flat = [];
            coords.forEach(pt => flat.push(pt[0], pt[1]));
            const prioridad = f.properties.prioridad || calcularPrioridad(f.properties);
            const extrudedHeight = prioridad * 12 + 1000; // escala visual
            const color = Cesium.Color.fromHsl((100 - prioridad) / 300, 0.85, 0.45, 0.8);
            try {
              viewer.entities.add({
                name: `PRIORITY_${f.properties.id}`,
                polygon: {
                  hierarchy: Cesium.Cartesian3.fromDegreesArray(flat),
                  extrudedHeight: extrudedHeight,
                  material: color,
                  outline: true,
                  outlineColor: Cesium.Color.WHITE
                },
                description: `Prioridad: ${prioridad}%`
              });
            } catch (err) {
              console.warn('No se pudo crear entidad Cesium para', f.properties.nombre, err);
            }
          });
        }

        // Actualizar gr√°fico de riskChart si existe (Chart.js)
        if (typeof riskChart !== 'undefined' && riskChart) {
          // Tomamos 3 indicadores promedio para mostrar en gr√°fico (demostrativo)
          const avgNDVI = (features.reduce((acc, f) => acc + (Number(f.properties.indice_acceso) || 50), 0) / features.length) / 100;
          const avgLST = (features.reduce((acc, f) => acc + (Number(f.properties.temp) || 28), 0) / features.length);
          const avgDens = (features.reduce((acc, f) => acc + (1000 * ((100 - (f.properties.cobertura_energia || 60)) / 100)), 0) / features.length) / 1000;
          riskChart.data.labels = ['Acceso normalizado', 'Temp promedio (¬∞C)', 'D√©ficit energ√©tico (norm)'];
          riskChart.data.datasets[0].data = [avgNDVI * 35, avgLST, avgDens * 5];
          try { riskChart.update(); } catch (e) { console.warn('No se pudo actualizar riskChart', e); }
        }

        // Centrar mapa en la √°rea con mayor prioridad
        if (results.length) {
          const top = results[0];
          const feat = simulatedAreas.features.find(x => x.properties.id === top.id);
          if (feat) {
            const bounds = L.geoJSON(feat).getBounds();
            map.fitBounds(bounds, { maxZoom: 13 });
          }
        }
      }

      /**************************************************************************
       * Integraci√≥n con el m√≥dulo IA existente (botones del sidebar)
       **************************************************************************/
      function integrateWithSidebar() {
        // Creamos un bloque peque√±o en el sidebar (no modificamos tu HTML original)
        const sidebarEl = document.getElementById('sidebar');
        if (!sidebarEl) return;

        // Contenedor
        const container = document.createElement('div');
        container.style.marginTop = '12px';
        container.style.paddingTop = '10px';
        container.style.borderTop = '1px solid #eee';
        sidebarEl.appendChild(container);

        document.getElementById('sim-run-priority').addEventListener('click', calcularYMostrarPrioridadesLeaflet);
        document.getElementById('sim-show-cesium').addEventListener('click', function () {
          const viewer = safeGetCesiumViewer();
          if (!viewer) {
            alert('Cesium no est√° inicializado. Cambia a 3D (bot√≥n "Cambiar a 3D") para inicializarlo y vuelve a intentar.');
            return;
          }
          // Forzamos rec√°lculo y pintado (ya maneja Cesium internamente)
          calcularYMostrarPrioridadesLeaflet();
        });
        document.getElementById('sim-clear-entities').addEventListener('click', function () {
          const map = safeGetMap();
          if (map) {
            // Removemos todas las capas que agregamos
            [accesoLayer, contaminacionLayer, parquesLayer, saludProposalsLayer, vertederosLayer, energiaLayer, calorLayer].forEach(l => {
              try { if (l && map.hasLayer(l)) map.removeLayer(l); } catch (e) { }
            });
          }
          const viewer = safeGetCesiumViewer();
          if (viewer) {
            const prev = viewer.entities.values.filter(e => e.name && e.name.startsWith('PRIORITY_'));
            prev.forEach(e => viewer.entities.remove(e));
          }
          document.getElementById('sim-status').textContent = 'Estado: simulaciones limpias';
        });
      }

      /**************************************************************************
       * Inicializar todo cuando el mapa est√© listo
       **************************************************************************/
      function bootWhenReady() {
        const map = safeGetMap();
        if (!map) {
          // Si mapInstance no existe a√∫n, reintentar
          setTimeout(bootWhenReady, 400);
          return;
        }
        // S√≥lo inicializar una vez
        if (window.__sim_layers_initialized) return;
        window.__sim_layers_initialized = true;

        initSimulatedLayers();
        integrateWithSidebar();

        // Si el m√≥dulo IA existe y hay bot√≥n / output en tu UI, lo enlazamos opcionalmente
        const aiPredictBtn = document.getElementById('ai-predict');
        if (aiPredictBtn) {
          // preservamos comportamiento original y a√±adimos c√°lculo de prioridad global como demo
          aiPredictBtn.addEventListener('click', function extraOnClick() {
            // recalculamos prioridades al usar IA demo
            calcularYMostrarPrioridadesLeaflet();
          });
        }
      }

      // lanzar
      bootWhenReady();

      // Exponer funciones a window para depuraci√≥n / uso en consola
      window.simulatedAreas = simulatedAreas;
      window.calcularPrioridad = calcularPrioridad;
      window.calcularYMostrarPrioridadesLeaflet = calcularYMostrarPrioridadesLeaflet;

      /* ----------------- M√≥dulos: Integraciones reales ----------------- */

      // Utilidades
      function safeGetMap() { if (typeof mapInstance !== 'undefined' && mapInstance) return mapInstance; return null; }
      function safeGetCesiumViewer() { if (typeof cesiumViewer !== 'undefined' && cesiumViewer) return cesiumViewer; return null; }

      /***** 1) OpenAQ: calidad del aire (puntos) *****/
      async function cargarContaminacionReal(radiusMeters = 50000) {
        const map = safeGetMap();
        if (!map) return null;
        const baseUrl = 'https://api.openaq.org/v2/latest';
        const params = new URLSearchParams({ coordinates: `${CAJAMARCA_COORDS[0]},${CAJAMARCA_COORDS[1]}`, radius: radiusMeters, limit: 50 });
        const url = `${baseUrl}?${params.toString()}`;

        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error('OpenAQ no responde');
          const data = await res.json();

          const layer = L.layerGroup();
          data.results.forEach(r => {
            const coord = r.coordinates || {}; // {latitude, longitude}
            if (!coord.latitude || !coord.longitude) return;
            // tomamos la primera medici√≥n significativa
            const m = r.measurements && r.measurements[0];
            const value = m ? m.value : null;
            const unit = m ? m.unit : '';
            const popup = `<b>${r.location}</b><br>${m ? `${m.parameter}: ${value} ${unit}` : 'Sin medici√≥n reciente'}<br>Fuente: OpenAQ`;

            const color = value === null ? '#999' : (value > 50 ? '#d73027' : '#1a9850');
            const radius = value === null ? 6 : Math.min(18, Math.max(6, Math.round(value / 3)));

            L.circleMarker([coord.latitude, coord.longitude], { radius, fillColor: color, color: '#fff', weight: 1, fillOpacity: 0.9 })
              .bindPopup(popup).addTo(layer);
          });

          layer.addTo(map);
          return layer;
        } catch (err) {
          console.warn('Error cargando OpenAQ:', err);
          return null;
        }
      }

      /***** 2) Open-Meteo: temperatura actual *****/
      async function actualizarTemperaturaReal() {
        const base = 'https://api.open-meteo.com/v1/forecast';
        const params = new URLSearchParams({ latitude: CAJAMARCA_COORDS[0], longitude: CAJAMARCA_COORDS[1], current_weather: true });
        const url = `${base}?${params.toString()}`;
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error('Open-Meteo no disponible');
          const data = await res.json();
          const temp = data && data.current_weather ? data.current_weather.temperature : null;
          if (temp !== null) {
            const slider = document.getElementById('ai-lst');
            const display = slider.parentNode.querySelector('.value-display');
            slider.value = temp;
            display.textContent = parseFloat(temp).toFixed(1);
            return temp;
          }
        } catch (err) {
          console.warn('Error Open-Meteo:', err);
          return null;
        }
      }

      /***** 3) NASA GIBS (MODIS NDVI) ‚Äî WMS tileLayer *****/
      function agregarNDVIReal() {
        const map = safeGetMap();
        if (!map) return null;
        try {
          const ndviLayer = L.tileLayer.wms('https://gibs.earthdata.nasa.gov/wms/epsg4326/best/wms.cgi', {
            layers: 'MODIS_Terra_NDVI_16Day',
            format: 'image/png',
            transparent: true,
            opacity: 0.6,
            attribution: 'NASA MODIS NDVI'
          });
          ndviLayer.addTo(map);
          return ndviLayer;
        } catch (err) {
          console.warn('No se pudo cargar NDVI WMS:', err);
          return null;
        }
      }

      /***** 4) Overpass (OpenStreetMap): hospitales/centros de salud *****/
      async function cargarCentrosSalud(radiusMeters = 50000) {
        const map = safeGetMap();
        if (!map) return null;

        const q = `
  [out:json][timeout:25];
  (
    node["amenity"~"hospital|clinic"](around:${radiusMeters},${CAJAMARCA_COORDS[0]},${CAJAMARCA_COORDS[1]});
    way["amenity"~"hospital|clinic"](around:${radiusMeters},${CAJAMARCA_COORDS[0]},${CAJAMARCA_COORDS[1]});
    relation["amenity"~"hospital|clinic"](around:${radiusMeters},${CAJAMARCA_COORDS[0]},${CAJAMARCA_COORDS[1]});
    node["healthcare"~"hospital|clinic|centre"](around:${radiusMeters},${CAJAMARCA_COORDS[0]},${CAJAMARCA_COORDS[1]});
    way["healthcare"~"hospital|clinic|centre"](around:${radiusMeters},${CAJAMARCA_COORDS[0]},${CAJAMARCA_COORDS[1]});
    relation["healthcare"~"hospital|clinic|centre"](around:${radiusMeters},${CAJAMARCA_COORDS[0]},${CAJAMARCA_COORDS[1]});
    node["building"="hospital"](around:${radiusMeters},${CAJAMARCA_COORDS[0]},${CAJAMARCA_COORDS[1]});
    way["building"="hospital"](around:${radiusMeters},${CAJAMARCA_COORDS[0]},${CAJAMARCA_COORDS[1]});
  );
  out center;
  `;

        try {
          const res = await fetch('https://overpass-api.de/api/interpreter', {
            method: 'POST',
            body: q
          });
          if (!res.ok) throw new Error('Overpass API fall√≥');
          const data = await res.json();

          const layer = L.layerGroup();
          data.elements.forEach(e => {
            const lat = e.lat || (e.center && e.center.lat);
            const lon = e.lon || (e.center && e.center.lon);
            if (!lat || !lon) return;

            const nombre =
              (e.tags && (e.tags.name || e.tags.operator)) || 'Centro de salud';
            const marker = L.marker([lat, lon], {
              icon: L.icon({
                iconUrl: 'img/markyellow.png',
                iconSize: [28, 28],
                iconAnchor: [14, 28]
              })
            }).bindPopup(`<b>${nombre}</b><br>Fuente: OpenStreetMap`);
            layer.addLayer(marker);
          });

          layer.addTo(map);
          return layer;
        } catch (err) {
          console.warn('Error Overpass:', err);
          return null;
        }
      }


      /***** 5) Densidad poblacional (fallback simple: WorldPop / placeholder) *****/
      // Implementar una integraci√≥n profunda con WorldPop o INEI requiere preprocesamiento.
      // Aqu√≠ dejaremos una llamada que puede apuntar a un geojson procesado si lo subes al servidor.
      async function cargarDensidadFallback() {
        // Si tienes un geojson con densidad por pol√≠gonos, reemplaza la URL
        const map = safeGetMap();
        if (!map) return null;
        try {
          // ejemplo: const res = await fetch('/data/densidad_cajamarca.geojson');
          // const gj = await res.json();
          // const lg = L.geoJSON(gj, { style: ... }).addTo(map);
          // return lg;
          return null; // no hay datos preprocesados en esta versi√≥n
        } catch (err) {
          console.warn('No hay densidad poblacional preprocesada:', err);
          return null;
        }
      }

      /***** 6) C√°lculo de prioridad (igual que antes, pero ahora usando propiedades reales cuando existan) *****/
      function calcularPrioridad(areaProps) {
        const wAcceso = 0.30, wContaminacion = 0.25, wEnergia = 0.20, wCalor = 0.25;
        const accesoScore = 100 - (Number(areaProps.indice_acceso) || 50);
        const contScore = Math.min(200, Number(areaProps.contaminacion || 50)) / 200 * 100;
        const energiaScore = 100 - (Number(areaProps.cobertura_energia) || 60);
        const calorScore = Math.min(40, Number(areaProps.temp || 28)) / 40 * 100;
        const raw = (accesoScore * wAcceso) + (contScore * wContaminacion) + (energiaScore * wEnergia) + (calorScore * wCalor);
        return Math.round(Math.min(100, Math.max(0, raw)));
      }

      /***** 7) Manejo de clicks en el mapa (ahora intentamos consultar Open-Meteo y NDVI aproximado) *****/
      async function handleMapClick(coords) {
        const ndvi = await sampleNDVI(coords.lat, coords.lng); // funci√≥n de muestreo (fallback si no es posible)
        const lst = await sampleLST(coords.lat, coords.lng);
        const dens = await sampleDensidad(coords.lat, coords.lng);

        if (clickMarker) mapInstance.removeLayer(clickMarker);
        clickMarker = L.circleMarker([coords.lat, coords.lng], { radius: 8, fillColor: 'var(--accent)', color: '#ffffff', weight: 2, opacity: 1, fillOpacity: 0.9 }).addTo(mapInstance).bindPopup(`Datos: NDVI ${ndvi?.toFixed(2) || 'N/A'}, LST ${lst?.toFixed(1) || 'N/A'}¬∞C`).openPopup();
        mapInstance.flyTo([coords.lat, coords.lng], 12, { animate: true, duration: 1 });

        const html = `
        <p><strong>üìç Coordenadas:</strong> ${coords.lat.toFixed(4)}, ${coords.lng.toFixed(4)}</p>
        <p><strong>üåø NDVI (Salud):</strong> <span style="color:${ndvi > 0.4 ? 'green' : 'orange'}; font-weight:700;">${ndvi ? ndvi.toFixed(2) : 'N/A'}</span></p>
        <p><strong>üî• LST (¬∞C):</strong> <span style="color:${lst > 30 ? 'red' : 'green'}; font-weight:700;">${lst ? lst.toFixed(1) : 'N/A'}</span></p>
        <p><strong>üë• Densidad (hab/km¬≤):</strong> <span style="font-weight:700;">${dens ? dens.toLocaleString() : 'N/D'}</span></p>
      `;
        document.getElementById('selected-metrics').innerHTML = html;

        const kpiAlto = document.getElementById('kpi-alto');
        const isHighRisk = (ndvi && ndvi < 0.3) || (lst && lst > 32);
        kpiAlto.textContent = isHighRisk ? '¬°ALTO! ‚ö†Ô∏è' : 'Bajo/Medio ‚úÖ';
        kpiAlto.style.color = isHighRisk ? '#ff4500' : 'var(--accent-dark)';
        document.getElementById('kpi-ndvi').textContent = ndvi ? ndvi.toFixed(2) : '--';

        if (ndvi) {
          const ndviPercent = ndvi * 100;
          ndviBar.style.position = 'relative';
          ndviBar.style.cursor = 'pointer';
          ndviBar.innerHTML = `<div style="position: absolute; top: -7px; left: ${ndviPercent}%; transform: translateX(-50%); width: 14px; height: 14px; border-radius: 50%; background: white; border: 2px solid var(--accent-dark); box-shadow: 0 1px 3px rgba(0,0,0,0.3); transition: left 0.5s ease-out;"></div>`;
        }

        updateRiskChart(ndvi || 0.5, lst || 26, dens || 500);

        if (window.innerWidth <= 900) sidebar.classList.remove('open');
      }

      // Muestreos y aproximaciones (NDVI, LST, Densidad)
      async function sampleNDVI(lat, lon) {
        // No existe una API sencilla para muestrear MODIS NDVI en un punto sin proxy; devolvemos una aproximaci√≥n basada en tile WMS (no se descarga el raster aqu√≠).
        // Para esta versi√≥n, devolvemos null y dejamos la capa WMS visible. Puedes implementar un servicio servidor-side para muestreos precisos.
        return null;
      }

      async function sampleLST(lat, lon) {
        // usamos Open-Meteo current_weather como aproximaci√≥n (esa API no da LST puntual pero da temperatura 2m)
        try {
          const base = 'https://api.open-meteo.com/v1/forecast';
          const params = new URLSearchParams({ latitude: lat, longitude: lon, current_weather: true });
          const res = await fetch(`${base}?${params.toString()}`);
          if (!res.ok) return null;
          const data = await res.json();
          return data && data.current_weather ? data.current_weather.temperature : null;
        } catch (err) { return null; }
      }

      async function sampleDensidad(lat, lon) {
        // sin integraci√≥n directa, devolvemos null. Si subes un GeoJSON con densidades, aqu√≠ har√≠amos un lookup.
        return null;
      }

      /* ----------------- M√≥dulo IA: regla ponderada (se mantiene) ----------------- */
      document.getElementById('ai-predict').addEventListener('click', async () => {
        const ndvi = parseFloat(document.getElementById('ai-ndvi').value);
        const lst = parseFloat(document.getElementById('ai-lst').value);
        const dens = parseFloat(document.getElementById('ai-den').value);
        const out = document.getElementById('ai-output');

        // Regla ponderada demo (0-1)
        const risk = Math.min(1, Math.max(0,
          0.5 * (1 - ndvi) + 0.35 * ((lst - 15) / 30) + 0.15 * (dens / 10000)
        ));
        const riskPct = Math.round(risk * 100);

        out.style.display = 'block';
        out.style.backgroundColor = `rgba(255, ${255 - riskPct * 2.55}, ${255 - riskPct * 2.55}, 0.8)`;
        out.innerHTML = `<div>Estimaci√≥n IA: <strong>Riesgo ${riskPct}%</strong> (${riskPct > 60 ? '¬°Alta prioridad!' : 'Prioridad baja/media'}).</div>`;

        // recalculamos prioridades globales si existen capas relevantes
        if (window.calcularYMostrarPrioridadesLeaflet) try { window.calcularYMostrarPrioridadesLeaflet(); } catch (e) { }
      });

      /* ----------------- Inicializaci√≥n de capas reales al cargar ----------------- */
      async function inicializarDatosReales() {
        // Esperamos a que mapInstance est√© listo
        const waitMap = new Promise(resolve => {
          const t = setInterval(() => { if (safeGetMap()) { clearInterval(t); resolve(); } }, 200);
        });
        await waitMap;

        // Cargamos capas en paralelo (fallos no bloqueantes)
        const promises = [cargarContaminacionReal(), actualizarTemperaturaReal(), cargarCentrosSalud(), agregarNDVIReal(), cargarDensidadFallback()];
        const [contLayer, temp, saludLayer, ndviLayer, densLayer] = await Promise.all(promises.map(p => p.catch ? p.catch(e => { console.warn(e); return null; }) : p));

        // A√±adir control de capas si mapInstance existe
        const map = safeGetMap();
        if (map) {
          const overlays = {};
          if (contLayer) overlays['Contaminaci√≥n (OpenAQ)'] = contLayer;
          if (saludLayer) overlays['Centros de Salud (OSM)'] = saludLayer;
          if (ndviLayer) overlays['NDVI (MODIS)'] = ndviLayer;
          if (densLayer) overlays['Densidad poblacional (preproc)'] = densLayer;
          if (Object.keys(overlays).length) L.control.layers(null, overlays, { collapsed: false, position: 'topleft' }).addTo(map);
        }

        // Actualizamos algunos KPIs iniciales
        if (typeof temp !== 'undefined' && temp !== null) {
          const display = document.querySelector('#ai-lst + .value-display');
          if (display) display.textContent = parseFloat(temp).toFixed(1);
        }

        // Exponer variables globales para depuraci√≥n
        window._real_layers = { contLayer, saludLayer, ndviLayer, densLayer };

        console.log('Datos reales inicializados.');
      }

      // Ejecutar inicializaci√≥n
      window.addEventListener('load', () => {
        inicializarDatosReales();
      });

      /* ----------------- Funciones de prioridad y visualizaci√≥n 3D (compatibilidad) ----------------- */
      // Conservamos la funci√≥n calcularYMostrarPrioridadesLeaflet similar a la versi√≥n simulada, pero
      // adaptada para trabajar si hay GeoJSON con propiedades. En esta versi√≥n si no hay datos simulados
      // la funci√≥n se limitar√° a notificar.
      function calcularYMostrarPrioridadesLeaflet() {
        const map = safeGetMap();
        if (!map) return;
        // Intentamos usar ventana simulatedAreas si existe (compatibilidad retro)
        const feats = window.simulatedAreas && window.simulatedAreas.features ? window.simulatedAreas.features : [];
        if (!feats.length) {
          const out = document.getElementById('ai-output');
          if (out) { out.style.display = 'block'; out.innerHTML = `<h4>√çndice de Prioridad</h4><p>No hay √°reas pre-cargadas para calcular prioridad (se requiere GeoJSON con propiedades).</p>`; }
          return;
        }

        const results = feats.map(f => ({ id: f.properties.id, nombre: f.properties.nombre, prioridad: calcularPrioridad(f.properties) }));
        results.sort((a, b) => b.prioridad - a.prioridad);

        const out = document.getElementById('ai-output');
        if (out) {
          out.style.display = 'block'; out.style.padding = '8px';
          out.innerHTML = `<h4>√çndice de Prioridad (calculado)</h4><ol>${results.map(r => `<li><strong>${r.nombre}</strong>: ${r.prioridad}%</li>`).join('')}</ol>`;
        }

        // Cesium extrusions (si existe viewer)
        const viewer = safeGetCesiumViewer();
        if (viewer) {
          // borramos previas
          const prev = viewer.entities.values.filter(e => e.name && e.name.startsWith('PRIORITY_'));
          prev.forEach(e => viewer.entities.remove(e));
          feats.forEach(f => {
            try {
              const coords = f.geometry.coordinates[0];
              const flat = []; coords.forEach(pt => flat.push(pt[0], pt[1]));
              const prioridad = calcularPrioridad(f.properties);
              const extrudedHeight = prioridad * 12 + 1000;
              const color = Cesium.Color.fromHsl((100 - prioridad) / 300, 0.85, 0.45, 0.8);
              viewer.entities.add({ name: `PRIORITY_${f.properties.id}`, polygon: { hierarchy: Cesium.Cartesian3.fromDegreesArray(flat), extrudedHeight, material: color, outline: true, outlineColor: Cesium.Color.WHITE }, description: `Prioridad: ${prioridad}%` });
            } catch (err) { console.warn('Error creando extrusi√≥n Cesium', err); }
          });
        }
      }

      // Exponer algunas utilidades globales para debugging
      window.calcularYMostrarPrioridadesLeaflet = calcularYMostrarPrioridadesLeaflet;

      /* ----------------- Mensajes / Fallbacks ----------------- */
      console.log('JS real cargado. Si falta alg√∫n dataset (densidad, NDVI muestreos), considera preprocesar y subir un GeoJSON al servidor y actualizar las funciones de carga.');

    })();
  </script>
  <!-- ------------------ FIN: Simulaciones y capas adicionales ------------------ -->

  </body>

</html>